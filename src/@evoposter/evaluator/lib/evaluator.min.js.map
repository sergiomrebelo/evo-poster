{"version":3,"file":"evaluator.min.js","sources":["../src/utils.js","../src/metrics.config.js","../src/metrics/Legibility.mjs","../src/metrics/SemanticsLayout.mjs","../src/metrics/SemanticsEmphasis.mjs","../semantics-visual.config.js","../src/metrics/SemanticVisuals.mjs","../src/metrics/Alignment.mjs","../src/metrics/WhiteSpaceFraction.mjs","../src/metrics/TypefaceParing.mjs","../src/metrics/VisualBalance.mjs","../src/index.mjs","../src/metrics/GridAppropriateSize.mjs","../src/metrics/Regularity.mjs"],"sourcesContent":["export const map = (value, minA, maxA, minB, maxB) => {\n    return minB + (maxB - minB) * ((value - minA) / (maxA - minA));\n}\n\nexport const constraint = (value, min, max) => {\n    return Math.min(max, Math.max(min, value));\n}\n\nexport const arrMean = (arr) => {\n    const sum = arr.reduce((a, b) => a + b, 0);\n    return (sum / arr.length) || 0;\n}\n\nexport const arrSum = (arr) => {\n    return arr.reduce((partialSum, a) => partialSum + a, 0);\n}\n\nexport const arrMax = (arr) => {\n    return Math.max(...arr);\n}\n\nexport const arrMin = (arr) => {\n    return Math.min(...arr);\n}\n\nexport const arrUnique = (arr) => {\n    return arr.filter((value, index, array) => array.indexOf(value) === index);\n}\n\nexport const sumProduct = (arr, weights) => {\n    return arr.reduce((s, v, i) => s + v * weights[i], 0);\n}\n\nexport const hexToRGB = (hex) => {\n    if (hex[\"levels\"]) {\n        return {\n            r: parseInt(hex[\"levels\"][0]),\n            g: parseInt(hex[\"levels\"][1]),\n            b: parseInt(hex[\"levels\"][2])\n        }\n    }\n\n    let result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16)\n    } : null;\n}\n\nexport const colorDistance = (a, b) => {\n    return Math.sqrt(Math.pow(a.r - b.r, 2) + Math.pow(a.g - b.g, 2) + Math.pow(a.b - b.b, 2));\n}","export const ALIGNMENT = {\n    \"A\": 10, // limit to the non-linear function\n    \"WEIGHTS\": [.8, .2] // alignment parts weights\n}\n\nexport const LEGIBILITY = {\n    \"MAX_CONSTRAINT\": 1,\n    \"WHITE_SPACE_FACTOR\": 3,\n    \"MODES\": [`OVERSET`, `JUSTIFY`,`ATTEMPT_JUSTIFY`],\n    \"DEFAULT_MAX_LIMIT_SCALE\": 1\n}\n\nexport const REGULARITY = {\n    \"A\": 10, // limit to the non-linear function\n}\n\nexport const SEMANTICS_EMPHASIS = {\n    \"MIN_RANGE\": 50,\n    \"THRESHOLD_VALID\": 0.2,\n    \"MODES\": [`DIF`, `MIN`]\n}\n\nexport const SEMANTICS_VISUALS = {\n    \"MAX_COLOR_DISTANCE\": 441.67\n}\n\nexport const SEMANTICS_LAYOUT = {\n    \"MODES\": [`RELATIVE`, `FIXED`]\n}\n\nexport const TYPEFACE_PARING = {\n    \"MODES\": [`BOTH`, `TYPE_FAMILY`, `CATEGORY`]\n}\n\nexport const VISUAL_BALANCE = {\n    \"VISUAL_CENTER_FT\": 20,\n    \"MODES\": [\n        `CENTER`,\n        `LEFT-CENTER`, `RIGHT-CENTER`,\n        `LEFT-TOP`, `RIGHT-TOP`,\n        `LEFT-BOTTOM`, `RIGHT-BOTTOM`]\n}\n\nexport const WHITE_SPACE_FRACTION = {\n    \"OPTIMAL\": .5,\n    \"MIN_DISTANCE\": 10\n}\n\n\nexport default {\n    \"DEBUG\": false,\n}","/**\n * Legibility\n *\n * Measure the legibility of the text in the poster\n * it is related to the legibility of the sentence\n * and not the typeface shapes\n *\n * Expected return a value between 0 (good) and (1) bad\n *\n * Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * srebelo[at]dei.uc.pt\n *\n * v1.0.0 August 2018 (as part of evoPoster)\n * v2.0.0 November 2020 (as part of evoPoster)\n * v2.5.0 November 2021 (as part of evoPoster)\n * v3.0.0 November 2023\n */\n\nimport {arrMean, map} from \"../utils.js\";\nimport {LEGIBILITY} from \"../metrics.config.js\";\n\nconst MAX_CONSTRAINT = LEGIBILITY[\"MAX_CONSTRAINT\"];\nconst WHITE_SPACE_FACTOR = LEGIBILITY[\"WHITE_SPACE_FACTOR\"];\nconst DEFAULT_MAX_LIMIT_SCALE = LEGIBILITY[\"DEFAULT_MAX_LIMIT_SCALE\"];\nconst AVAILABLE_MODES = LEGIBILITY [\"MODES\"]\n\nexport const compute = (sentencesLength = [], minSize, mode= 'OVERSET', maxLimitScale= DEFAULT_MAX_LIMIT_SCALE) => {\n    if (!AVAILABLE_MODES.includes(mode)) {\n        mode = `OVERSET`;\n    }\n    let results = [];\n    let max = minSize * maxLimitScale;\n    for (let sentence of sentencesLength) {\n        let dif = minSize-sentence;\n        let value = MAX_CONSTRAINT;\n        switch (mode) {\n            case `JUSTIFY`:\n                value = justify(dif, max);\n                break;\n            case `ATTEMPT_JUSTIFY`:\n                value = attemptJustify(dif, max);\n                break;\n            default:\n                value = overset(dif, max);\n                break;\n        }\n        results.push(value);\n    }\n\n    // calculate mean\n    const mean = arrMean([...results]);\n\n    return mean;\n}\n\nconst overset = (value, max) => {\n    // only prejudice when text overfits the poster\n    // if dif bigger than 0\n    value = value >= 0 ? 0 : value;\n    // if dif lower than limit\n    value = value <= -max ? -max : value;\n    // transform in scale of 1 (bad) to 0 (good)\n    return map (value, -max, 0, MAX_CONSTRAINT, 0);\n}\n\nconst justify = (value, max) => {\n    // prejudice both overset and small lettering\n    value = Math.abs(value)\n    // if the dif is bigger than max\n    value = value > max ? max : value;\n    // transform in scale of 1 (bad) to 0 (good)\n    return map (value, max, 0, MAX_CONSTRAINT, 0);\n}\n\n// attempt to justify the text\n// prejudice more when the text overset box than when it is smaller\nconst attemptJustify = (value, max) => {\n    // if dif bigger than 0 (it is not overset), soften the value\n    value = value >= 0 ? value/WHITE_SPACE_FACTOR : value;\n    return justify(value, max);\n}\n\nexport { compute as default };","/**\n * Layout Semantics\n *\n * Measure the appropriate of the layout\n * based on the importance of the content\n * it considers that most important parts of content\n * are those have more emotions related\n *\n * return the mean of difference between all textboxes,\n * a value between 1 (good) and 0 (bad)\n *\n * two modes: RELATIVE and FIXED\n * RELATIVE mode is related to the composition height\n * FIXED height is related to the container's height\n *\n * Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * srebelo[at]dei.uc.pt\n *\n * v1.0.0 April 2020\n * v2.0.0 November 2023\n */\n\nimport {arrMean, arrSum} from \"../utils.js\";\nimport {SEMANTICS_LAYOUT} from \"../metrics.config.js\";\n\nconst AVAILABLE_MODES = SEMANTICS_LAYOUT[\"MODES\"];\n\nexport const compute = (textboxesHeights = [], dist = null, mode=`RELATIVE`, size = {height: 100, margin:[0,0,0,0]}) => {\n    // mode validation\n    if (!AVAILABLE_MODES.includes(mode)) mode = `RELATIVE`;\n\n    // define max height\n    let height = 0;\n    if (mode === `RELATIVE`) {\n        // using the textbox height\n        height = arrSum(textboxesHeights);\n    } else if (mode === `FIXED`) {\n        // using container height\n        height = size.height - ((size.height*size.margin[1]) + (size.height*size.margin[3]));\n    }\n    const percents = textboxesHeights.map((p) => p/height);\n\n    // calculate distances\n    let distances = [];\n    for (let i in dist) {\n        const dif = Math.abs(dist[i][3] - percents[i]);\n        distances.push(dif);\n    }\n\n    // return average\n    return (1-arrMean(distances));\n}\n\nexport { compute as default };","/**\n * Semantics Emphasis on Visuals\n *\n * Measure the appropriate of the visual features\n * based on the importance of the content\n * it considers that most important parts of content\n * are those have more emotions related\n *\n * return the mean of difference between all textboxes,\n * a value between 1 (good) and 0 (bad)\n *\n * two modes: MIN and DIF\n * MIN takes into account that the most important parts\n * are typeset in the min value possible in the container\n * DIF: take into account only the difference between the parts\n * selects a style and compare based on the distribution of emotions.\n *\n *\n *\n * Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * srebelo[at]dei.uc.pt\n *\n * v1.0.0 November 2023\n */\nimport {arrMax, arrMean, arrMin, arrSum, constraint, map} from \"../utils.js\";\nimport {SEMANTICS_EMPHASIS} from \"../metrics.config.js\";\n\nlet MIN_RANGE = SEMANTICS_EMPHASIS[\"MIN_RANGE\"];\nlet THRESHOLD_VALID = SEMANTICS_EMPHASIS[\"THRESHOLD_VALID\"];\nlet AVAILABLE_MODES = SEMANTICS_EMPHASIS[\"MODES\"];\n\n// by tradition, use more that a method to emphasize\n// the text is considered \"typecrime\".\n// this method enables turn on/off this feature\n// by using the param allowMultiple\nexport const compute = (textboxes, dist, noCurrentTypefaces = 1, allowMultiple = true, weights = [0.4, 0.3, 0.3]) => {\n    // if textboxes size is 1 ---> 1\n    const perDist = dist.map((e) => e[3]);\n\n    const fontWeight = checkDifferenceVariableFeature(textboxes.map((b) => b[\"weight\"]), perDist);\n    const fontStretch = checkDifferenceVariableFeature(textboxes.map((b) => b[\"font-stretch\"]), perDist);\n    let typefaceDesign = noCurrentTypefaces > 1 ? (checkDifferenceUniqueFeatures(textboxes.map((b) => b[\"font-stretch\"]), perDist)) : 0;\n\n    // way of combine and only checks one\n    let res = [fontWeight, fontStretch, typefaceDesign];\n    let weightedRes = res.map((x,i) => x*weights[i]);\n\n    let value;\n\n    if (!allowMultiple) {\n        // if not allowed multiple emphasis\n        // we check what fields are active\n        // and penalty when there is active fields\n        let active = res.map((r) => r > THRESHOLD_VALID);\n        let c = 0;\n        for (let a of active) {\n            if (a) {\n                c++;\n            }\n        }\n        value = arrMax(res)/c;\n    } else {\n        value = arrSum(weightedRes);\n    }\n\n    return value;\n}\n\n// check the levels\nconst checkDifferenceUniqueFeatures = (currentFeatures, dist) => {\n    // available semantic level\n    const uniqueValues = dist.filter((value, index, array) => array.indexOf(value) === index);\n    const target = [];\n\n    // define the target typeface for each semantic level\n    for (let uq of uniqueValues) {\n        for (let i=0; i<dist.length; i++) {\n            if (dist[i] === uq) {\n                target.push(currentFeatures[i]);\n                break;\n            }\n        }\n    }\n\n    // check if the target has duplicates\n    const duplicates = target.filter((item, index) => target.indexOf(item) !== index);\n\n    let value = 1;\n    // if there is duplicate in levels\n    // (if yes, difference is max)\n    if (!duplicates.length >= 1) {\n        // count the amount of tb not in the same typeface\n        let c = 0;\n        // for each typeface\n        for (let i in dist) {\n            let level = dist[i];\n            let currentValue = currentFeatures[i];\n            // get unique index of current semantic level\n            let index = uniqueValues.indexOf(level);\n            // get target value\n            let targetValue = target[index];\n            if (currentValue !== targetValue) {\n                // if not the same as target\n                c++;\n            }\n        }\n        // map value to a value between 0 (no difference) and 1 (max difference)\n        value = map(c, 0, currentFeatures.length, 0, 1);\n    }\n\n    return value;\n}\n\nconst checkDifferenceVariableFeature = (currentFeatures, dist, mode = `DIF`) => {\n    if (!AVAILABLE_MODES.includes(mode)) {\n        mode = `DIF`;\n    }\n    // max feature range\n    const maxFeature = arrMax(currentFeatures);\n    const minFeature = arrMin(currentFeatures);\n    let range = Math.abs(maxFeature - minFeature);\n    if (range < MIN_RANGE) {\n        return 1;\n    }\n\n    // semantic data range\n    const maxSemantic = arrMax(dist);\n    const minSemantic = arrMin(dist);\n\n    // consider the current variable minimum\n    let def = minFeature;\n    if (mode === `DIF`) {\n        // selects a style used in the first min semantic textbox\n        for (let i in dist) {\n            if (dist[i] === minSemantic) {\n                // consider the difference\n                def = currentFeatures[i];\n                break;\n            }\n        }\n    }\n\n    // create target feature values\n    const target = dist.map((e) => {\n        // The most neutral sentence are the most regular\n        let v = map(e, minSemantic, maxSemantic, 0, range);\n        v = constraint(v, 0, range);\n        return v;\n    });\n\n    // distance to target\n    const current = [];\n    for (let i in currentFeatures) {\n        let w = currentFeatures[i];\n        let currentDistance = Math.abs(w - def);\n        let dif = Math.abs(currentDistance - target[i]);\n        current.push(dif);\n    }\n\n    let mean = map(arrMean(current), 0, range, 1, 0);\n    return constraint(mean, 0, 1);\n}\n\n\n\n\nexport { compute as default };","export default {\n    anger : {\n        color: {\n            typography: [`#ff0000`, `#00ff00`],\n            background: [`#ff0000`]\n        },\n        typefaces: [`sans-serif`, `neo-grotesque`]\n    },\n    joy: {\n        color: {\n            typography: [],\n            background: [`#ffff00`, `#00ff00`]\n        },\n        typefaces: [`sans-serif`, `serif`]\n    },\n    trust: {\n        color: {\n            typography: [],\n            background: [`#0000ff`, `#00ff00`]\n        },\n        typefaces: [`neo-grotesque`]\n    },\n    sadness: {\n        color: {\n            typography: [],\n            background: [`#0071b6`]\n        },\n        typefaces: []\n    },\n    disgust: {\n        color: {\n            typography: [`#800080`],\n            background: []\n        },\n        typefaces: []\n    }\n}","/**\n * Semantic Visuals Measure\n *\n * This function assesses the appropriateness of visual features (type design and colour)\n * based on the emotions collected. It takes into account the configuration file \"visual-semantics.config.js\".\n *\n * The function returns the mean difference between all textboxes,\n * yielding a value between 1 (good) and 0 (bad).\n * If there is no information pertaining to a particular emotion, the value defaults to 1.\n *\n * As of now, the function exclusively considers the predominant emotions from ML analysis.\n *\n * Author: Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * Contact: srebelo[at]dei.uc.pt\n *\n * Version: 1.0.0 (November 2023)\n */\n\nimport {SEMANTICS_VISUALS} from \"../metrics.config.js\";\n\nconst MAX_COLOR_DISTANCE = SEMANTICS_VISUALS[\"MAX_COLOR_DISTANCE\"];\n\nimport * as configurationFile from \"../../semantics-visual.config.js\";\nimport {arrMean, colorDistance, hexToRGB, constraint} from \"../utils.js\";\n\n\nexport const compute = async (data, textboxes, background, typefaceData, config = configurationFile) => {\n\n    let emotion = data.predominant.emotion;\n\n    if (config[\"default\"][emotion] === undefined) return 1;\n\n    const targetTypefaceColors = config[\"default\"][emotion][\"color\"][\"typography\"];\n    const targetBackgroundColors = config[\"default\"][emotion][\"color\"][\"background\"];\n    const targetTypographyFeatures = config[\"default\"][emotion][\"typefaces\"];\n\n    // typography colour\n    let meanTypefaceColorDistance = 1;\n    if (targetTypefaceColors !== undefined && targetTypefaceColors.length > 0) {\n        let typefaceColorsDistances = [];\n        for (let t of textboxes) {\n            let c = hexToRGB(t.color);\n            let typefaceColorsDist = Number.MAX_VALUE;\n            for (let targetColor of targetTypefaceColors) {\n                targetColor = hexToRGB(targetColor);\n                let distance = colorDistance(c, targetColor)\n                if (distance < typefaceColorsDist) {\n                    typefaceColorsDist = distance;\n                }\n            }\n            typefaceColorsDistances.push(typefaceColorsDist);\n        }\n\n        meanTypefaceColorDistance = typefaceColorsDistances.length < 1 ? 1 : arrMean(typefaceColorsDistances);\n        meanTypefaceColorDistance /= MAX_COLOR_DISTANCE;\n        meanTypefaceColorDistance = constraint(1-meanTypefaceColorDistance, 0, 1);\n    }\n\n    // background colour\n    let meanTypefaceBackgroundDistance = 1;\n    if (targetBackgroundColors !== undefined && targetBackgroundColors.length !== 0) {\n        let backgroundColorsDistances = [];\n        meanTypefaceBackgroundDistance = 0;\n        for (let c of background) {\n            c = hexToRGB(c);\n            let backgroundColorsDist = Number.MAX_VALUE;\n            for (let targetColor of targetBackgroundColors) {\n                targetColor = hexToRGB(targetColor);\n                let distance = colorDistance(c, targetColor);\n                if (distance < backgroundColorsDist) {\n                    backgroundColorsDist = distance;\n                }\n            }\n            backgroundColorsDistances.push(backgroundColorsDist);\n        }\n\n        meanTypefaceBackgroundDistance = meanTypefaceBackgroundDistance.length < 1 ? 1 : arrMean(backgroundColorsDistances);\n        meanTypefaceBackgroundDistance /= MAX_COLOR_DISTANCE;\n        meanTypefaceBackgroundDistance = constraint(1-meanTypefaceBackgroundDistance, 0, 1);\n    }\n\n    // typeface\n    let meanTypefaceError = 1;\n    if (targetTypographyFeatures !== undefined && targetTypographyFeatures.length > 0) {\n        let fontsTags = [];\n        for (let t of textboxes) {\n            let tbTagsValue = 0;\n            const typefaceIndex = typefaceData.map(t => t.family).indexOf(t[\"typeface\"]);\n            const tags = typefaceData[typefaceIndex][\"tags\"];\n            for (let t of targetTypographyFeatures) {\n                if (tags.includes(t)) {\n                    tbTagsValue += (1/targetTypographyFeatures.length)\n                }\n            }\n            fontsTags.push(tbTagsValue);\n        }\n\n        meanTypefaceError = fontsTags.length < 1 ? 1 : arrMean(fontsTags);\n        meanTypefaceError = constraint(meanTypefaceError, 0, 1);\n    }\n\n    return (meanTypefaceColorDistance + meanTypefaceBackgroundDistance + meanTypefaceError)/3;\n\n\n}\n\n\nexport {compute as default};","/**\n * Alignment metric\n *\n * Estimate if the horizontal alignment of text boxes follows a regular pattern\n * Based on Harrington et al. (2004).\n *\n * Include the check if the text Alignment is the same (part B).\n * User can modify the value of WEIGHTS when necessary.\n *\n * return a value between 1 (good) and 0 (bad)\n *\n * Author: Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * Contact: srebelo[at]dei.uc.pt\n *\n * Version 1.0.0 (March 2020)\n * Version: 1.5.0 (November 2023)\n */\n\nimport {arrMean, arrUnique, sumProduct} from \"../utils.js\";\nimport {ALIGNMENT} from \"../metrics.config.js\";\n\nconst A = ALIGNMENT[\"A\"]\nconst WEIGHTS = ALIGNMENT[\"WEIGHTS\"];\n\nexport const compute = (sentenceWidth, textAlignment, weights = WEIGHTS) => {\n    if (sentenceWidth.length < 2) {\n        return 1;\n    }\n\n    let histogram = sentenceWidth;\n    let results = [];\n\n    for (let i = 0; i<histogram.length-1; i++) {\n        let z = Math.abs(histogram[i] - histogram [i+1]);\n        let v = A / (A + z);\n        results.push(v);\n    }\n\n    let resHistogramDif = arrMean(results);\n    let availableTextAligns = arrUnique(textAlignment).length;\n    let resTextAlign = 1/availableTextAligns;\n\n    let res = sumProduct([resHistogramDif, resTextAlign], weights);\n    return res;\n}\n\nexport {compute as default};","import {colorDistance, hexToRGB} from \"../utils.js\";\nimport {WHITE_SPACE_FRACTION} from \"../metrics.config.js\";\n\n/**\n * White Space Fraction metric\n *\n * Assess the white space factor, i.e. the amount of the result that is background.\n * Based on Harrington et al. (2004).\n *\n * Traditionally, white space (including margins) should total about half of the total page area.\n *\n * We decided made this in other way, using the pixels of image that are equals to background color\n *\n * return a value between 1 (good) and 0 (bad)\n * in first version, we used a no-linear method and onlyy works with solid backgrounds\n *\n * Author: Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * Contact: srebelo[at]dei.uc.pt\n *\n * Version 1.0.0 (March 2020)\n * Version: 1.5.0 (November 2023)\n */\n\nconst OPTIMAL = WHITE_SPACE_FRACTION[\"OPTIMAL\"];\nconst MIN_DISTANCE = WHITE_SPACE_FRACTION[\"MIN_DISTANCE\"];\n\nexport const compute = (img, color, amount = null, optimal = OPTIMAL) => {\n    if (amount === null) {\n        color = hexToRGB(color);\n        amount = percentTypographyColor(img, color, img.pixelDensity());\n    }\n\n    const res = 1-4*Math.pow((amount - optimal), 2);\n\n    return res;\n}\n\nconst percentTypographyColor = (img, c, d=1) => {\n    let amount = 0;\n    let distances = [];\n    let size = img.width * d * img.height * d ;\n    img.loadPixels();\n    for (let i = 0; i < 4 * size; i += 4) {\n        let current = {\n            r: img.pixels[i],\n            g: img.pixels[i+1],\n            b: img.pixels[i+2]\n        }\n        const distance = colorDistance(current, c);\n        distances.push(distance);\n        if (distance < MIN_DISTANCE) {\n            amount++;\n        }\n    }\n    return amount/size;\n}\n\nexport {compute as default};","import {arrUnique} from \"../utils.js\";\nimport {TYPEFACE_PARING} from \"../metrics.config.js\";\n\n/**\n * Typeface Pairing Metric\n *\n * Checks if the employed typefaces pair well together.\n * Since each typeface is related to a line of text,\n * this metric considers the typeface name and the classification.\n * Typefaces should be included in the configuration file with corresponding classification values.\n *\n * It had three modes:\n * TYPEFACE: values the use of the same typeface\n * CATEGORY: values the use of typefaces in the same category\n * BOTH: values both\n *\n *\n * Returns a value between 1 (good) and 0 (bad) to indicate compatibility.\n *\n * Author: Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * Contact: srebelo[at]dei.uc.pt\n *\n * Version 1.0.0 (March 2020)\n * Updated Version: 1.5.0 (November 2023)\n */\n\nconst AVAILABLE_MODES = TYPEFACE_PARING[\"MODES\"]\n\nexport const compute = (typefaces, availableTypefaces, mode = `BOTH`) => {\n    if (!AVAILABLE_MODES.includes(mode))  {\n        mode = `BOTH`;\n    }\n\n    let weights = [.5, .5]; // heights to BOTH mode\n    if (mode === `TYPE_FAMILY`) {\n        weights = [1, 0];\n    } else if (mode === `CATEGORY`) {\n        weights = [0, 1];\n    }\n\n    let categories = [];\n    let usedTypefaces = arrUnique(typefaces);\n    let categoriesFactor = 0, typefaceFactor = 0;\n\n    if (mode !== `TYPE_FAMILY`) {\n        const typefacesNames = availableTypefaces.map(a => a[\"family\"]);\n        const typefacesClassification = availableTypefaces.map(a => a[\"category\"]);\n\n        for (let typeface of usedTypefaces) {\n            const index = typefacesNames.indexOf(typeface);\n            if (index === -1) {\n                categories.push(`undefined`);\n            } else {\n                categories.push(typefacesClassification[index]);\n            }\n        }\n\n        categories = arrUnique(categories);\n        categoriesFactor = 1/categories.length;\n    }\n\n    if (mode !== `CATEGORY`) {\n        typefaceFactor = 1 / usedTypefaces.length;\n    }\n\n    const res = [typefaceFactor, categoriesFactor].reduce((s, v, i) => s + v * weights[i], 0);\n\n    return res;\n}\n\nexport {compute as default};","/**\n * Visual Balance metric\n *\n * Estimate the visual balance (centred) of the composition.\n * Based on Harrington et al. (2004)\n *\n *\n * Author: Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * Contact: srebelo[at]dei.uc.pt\n *\n * Version 1.0.0 (March 2020)\n * Version: 1.5.0 (November 2023)\n */\n\nimport {arrSum, constraint} from \"../utils.js\";\nimport {VISUAL_BALANCE} from \"../metrics.config.js\";\n\n// visual center factor\n// By default, the visual center is taken to be offset a twentieth of the page height towards the top\nconst VISUAL_CENTER_FT = VISUAL_BALANCE[\"VISUAL_CENTER_FT\"];\nconst AVAILABLE_MODES = VISUAL_BALANCE[\"MODES\"];\n\nexport const compute = async (img = null, size, rows, widths, heights, mode= `CENTER`, visualWeights = null) => {\n    const dx = size[\"width\"];\n    const dy = size[\"height\"];\n    if (!AVAILABLE_MODES.includes(mode)) mode = `CENTER`;\n\n    const vw = visualWeights === null ? await visualWeight(img, rows, widths, heights) : visualWeights;\n    const bo = balanceCenter(mode, vw, widths, heights);\n    let vo = visualCenter(mode, dx, dy, size[\"margin\"]);\n\n    // calculate central Balance\n    let cb = Math.pow(((bo.x-vo.x)/dx), 2) + Math.pow(((bo.y-vo.y)/dy), 2);\n    cb = 1-Math.pow(Math.abs(cb/2), 1/2);\n\n    return constraint(cb, 0, 1);\n}\n\n\nconst balanceCenter = (mode, vws, widths, heights) => {\n\n    // get text box center\n    const vc = [];\n    for (let i in heights) {\n        vc.push(visualCenter(mode, widths[i], heights[i]));\n    }\n\n    // get page balance center\n    let posX = 0, posY = 0;\n    const m = arrSum(vws);\n\n    for (let i in vws) {\n        posX += vc[i].x*vws[i];\n        posY += vc[i].y*vws[i];\n    }\n\n    posX /= m;\n    posY /= m;\n\n    return {\n        x: posX,\n        y: posY\n    }\n}\n\n\n/**\n* Calculate the visual centre of a element\n* The visual center lies halfway between the left and right edges\n* the visual center is taken to be offset a twentieth of the page height towards the top\n*/\nconst visualCenter = (mode, width, height, margins = [0,0,0,0]) => {\n    mode = String(mode)\n    const posX = mode.includes(`LEFT`) ? 1 : mode.includes(`RIGHT`) ? 2 : 0;\n    const posY = mode.includes(`TOP`) ? 1 : mode.includes(`BOTTOM`) ? 2 : 0;\n\n    let x = posX === 0 ? width/2 :\n        posX === 1 ? (width * margins[0]) : width * (1 - margins[2]) ;\n    let y = posY === 0 ? height/2 - (height/VISUAL_CENTER_FT) :\n        posY === 1 ? (height * margins[1]) : height - (height * margins[3])\n\n\n\n    return {\n        x: x,\n        y: y\n    }\n}\n\n/**\n * calculate the visual weight of a object\n * visual weight = area x optical density\n */\nconst visualWeight = async (img, rows, widths, heights) => {\n    let areas = [];\n    let opticalDensity = [];\n\n    for (let i in widths) {\n\n        // compute areas\n        areas.push(widths[i] * heights[i]);\n\n        // compute visual weight\n        const rendering = await img.get(\n            0,\n            img.height/2 + rows[\"center\"][i],\n            img.width,\n            rows[\"l\"][i]\n        );\n\n        await rendering.loadPixels();\n\n        let r = 0, g = 0, b = 0;\n        const realPixelsSize = rendering.pixels.length/4;\n\n        for (let i=0; i < rendering.pixels.length; i+=4) {\n            r += rendering.pixels[i];\n            g += rendering.pixels[i+1];\n            b += rendering.pixels[i+2];\n        }\n\n        r = Math.round(r/realPixelsSize);\n        g = Math.round(g/realPixelsSize);\n        b = Math.round(b/realPixelsSize);\n\n        const avgLuma = (0.2126*r + 0.7152*g + 0.0722*b);\n        const t = avgLuma / 255;\n        opticalDensity.push(-Math.log10(t));\n    }\n\n    return areas.map((a, i) => a * opticalDensity[i]);\n}\n\n\nexport {compute as default};\n","/**\n * Evaluation metrics for evo-poster\n * Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * srebelo[at]dei.uc.pt\n *\n * v0.0.1 July 2023\n */\n\nimport * as Legibility from \"./metrics/Legibility.mjs\";\nimport * as GridAppropriateSize from \"./metrics/GridAppropriateSize.mjs\";\nimport * as SemanticsLayout from \"./metrics/SemanticsLayout.mjs\";\nimport * as SemanticsEmphasis from \"./metrics/SemanticsEmphasis.mjs\";\nimport * as SemanticsVisuals from \"./metrics/SemanticVisuals.mjs\";\nimport * as Alignment from \"./metrics/Alignment.mjs\";\nimport * as Regularity from \"./metrics/Regularity.mjs\";\nimport * as WhiteSpaceFraction from \"./metrics/WhiteSpaceFraction.mjs\";\nimport * as TypefaceParing from \"./metrics/TypefaceParing.mjs\";\nimport * as VisualBalance from \"./metrics/VisualBalance.mjs\";\n\n\nexport const legibility = Legibility.compute;\nexport const gridAppropriateSize = GridAppropriateSize.compute;\nexport const semanticsLayout = SemanticsLayout.compute;\nexport const semanticsEmphasis = SemanticsEmphasis.compute;\nexport const semanticsVisuals = SemanticsVisuals.compute;\nexport const alignment = Alignment.compute;\nexport const regularity = Regularity.compute;\nexport const whiteSpaceFraction = WhiteSpaceFraction.compute;\nexport const typefaceParing = TypefaceParing.compute;\nexport const visualBalance = VisualBalance.compute;\n\nexport default () => {\n    console.log (`@evo-poster · evaluator v2.00`)\n}\n","/**\n * Grid Size Appropriateness\n *\n * Measure the appropriate of the used grid to the size of container\n * it is related to if the width and height of the grid is\n * in accordance with poster size\n *\n * Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * srebelo[at]dei.uc.pt\n *\n * v1.0.0 November 2023\n */\n\nimport * as CONFIG from \"../metrics.config.js\";\n\nconst DEBUG = CONFIG[\"default\"][\"DEBUG\"];\n\nexport const compute = (containerWidth, containerHeight, rows = [], columns = [], margins = {left:0, top:0, right:0, bottom:0}) => {\n    let invalid = false;\n    // debug\n    let msg = \"\";\n\n    // height calculation\n    let height = Math.abs(margins.top)+Math.abs(margins.bottom);\n    for (let r of rows) {\n        height = height + parseFloat(r);\n    }\n    // width calculation\n    let width = Math.abs(margins.left)+Math.abs(margins.right);\n    for (let r of columns) {\n        width = width + parseFloat(r);\n    }\n\n    width = Math.round(width);\n    height = Math.round(height);\n\n    if (height > containerHeight) {\n        invalid = true;\n        msg += `Grid height is bigger than container (grid:${height}, container:${containerHeight}). `;\n    } else if (height < containerHeight) {\n        msg += `Grid and container height are not the same (grid:${height}, container:${containerHeight}). `;\n    }\n\n    if (width > containerWidth) {\n        invalid = true;\n        msg += `Grid width is bigger than container (grid:${width}, container:${containerWidth}). `;\n    } else if (width < containerWidth) {\n        msg += `Grid and container width are not the same (grid:${width}, container:${containerWidth}). `;\n    }\n\n    if (msg !== \"\" && DEBUG) {\n        console.warn(msg);\n    }\n\n    return invalid ? 1 : 0;\n}\n\nexport { compute as default };","/**\n * Alignment metric\n *\n * Estimate if the text boxes follows a regular vertical pattern\n * Based on Harrington et al. (2004).\n *\n *\n * return a value between 1 (good) and 0 (bad)\n *\n * Author: Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * Contact: srebelo[at]dei.uc.pt\n *\n * Version 1.0.0 (March 2020)\n * Version: 1.5.0 (November 2023)\n */\n\nimport {arrMean} from \"../utils.js\";\nimport {REGULARITY} from \"../metrics.config.js\";\n\nconst A = REGULARITY[\"A\"];\n\nexport const compute = (heights) => {\n    if (heights.length < 2) {\n        return 1;\n    }\n\n    const histogram = heights;\n\n    let results = [];\n\n    for (let i = 0; i<histogram.length-1; i++) {\n        let z = Math.abs(histogram[i] - histogram [i+1]);\n        let v = A / (A + z);\n        results.push(v);\n    }\n\n    const res = arrMean(results);\n\n    return res;\n}\n\nexport {compute as default};"],"names":["map","value","minA","maxA","minB","maxB","constraint","min","max","Math","arrMean","arr","reduce","a","b","length","arrSum","partialSum","arrMax","arrMin","arrUnique","filter","index","array","indexOf","hexToRGB","hex","r","parseInt","g","result","exec","colorDistance","sqrt","pow","ALIGNMENT","LEGIBILITY","MAX_CONSTRAINT","WHITE_SPACE_FACTOR","MODES","DEFAULT_MAX_LIMIT_SCALE","SEMANTICS_EMPHASIS","MIN_RANGE","THRESHOLD_VALID","TYPEFACE_PARING","VISUAL_BALANCE","VISUAL_CENTER_FT","WHITE_SPACE_FRACTION","AVAILABLE_MODES","overset","justify","abs","attemptJustify","checkDifferenceUniqueFeatures","currentFeatures","dist","uniqueValues","target","uq","i","push","duplicates","item","c","level","currentValue","checkDifferenceVariableFeature","mode","includes","maxFeature","minFeature","range","maxSemantic","minSemantic","def","e","v","current","w","currentDistance","dif","mean","semanticsVisual_config","anger","color","typography","background","typefaces","joy","trust","sadness","disgust","MAX_COLOR_DISTANCE","A","WEIGHTS","OPTIMAL","MIN_DISTANCE","percentTypographyColor","img","d","amount","size","width","height","loadPixels","pixels","balanceCenter","vws","widths","heights","vc","visualCenter","posX","posY","m","x","y","margins","String","visualWeight","async","rows","areas","opticalDensity","rendering","get","realPixelsSize","round","t","log10","legibility","sentencesLength","minSize","maxLimitScale","results","sentence","gridAppropriateSize","containerWidth","containerHeight","columns","left","top","right","bottom","invalid","msg","parseFloat","semanticsLayout","textboxesHeights","margin","percents","p","distances","semanticsEmphasis","textboxes","noCurrentTypefaces","allowMultiple","weights","perDist","res","weightedRes","active","semanticsVisuals","data","typefaceData","config","configurationFile","emotion","predominant","undefined","targetTypefaceColors","targetBackgroundColors","targetTypographyFeatures","meanTypefaceColorDistance","typefaceColorsDistances","typefaceColorsDist","Number","MAX_VALUE","targetColor","distance","meanTypefaceBackgroundDistance","backgroundColorsDistances","backgroundColorsDist","meanTypefaceError","fontsTags","tbTagsValue","typefaceIndex","family","tags","alignment","sentenceWidth","textAlignment","histogram","z","s","sumProduct","regularity","whiteSpaceFraction","optimal","pixelDensity","typefaceParing","availableTypefaces","categories","usedTypefaces","categoriesFactor","typefaceFactor","typefacesNames","typefacesClassification","typeface","visualBalance","visualWeights","dx","dy","vw","bo","vo","cb","console","log"],"mappings":"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"}