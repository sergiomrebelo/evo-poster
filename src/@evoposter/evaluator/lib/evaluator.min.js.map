{"version":3,"file":"evaluator.min.js","sources":["../src/utils.js","../src/metrics.config.js","../src/metrics/Legibility.mjs","../src/metrics/SemanticsLayout.mjs","../src/metrics/SemanticsEmphasis.mjs","../semantics-visual.config.js","../src/metrics/SemanticVisuals.mjs","../src/metrics/Alignment.mjs","../src/metrics/WhiteSpaceFraction.mjs","../src/metrics/TypefaceParing.mjs","../src/metrics/VisualBalance.mjs","../src/index.mjs","../src/metrics/GridAppropriateSize.mjs","../src/metrics/Regularity.mjs"],"sourcesContent":["export const map = (value, minA, maxA, minB, maxB) => {\n    return minB + (maxB - minB) * ((value - minA) / (maxA - minA));\n}\n\nexport const constraint = (value, min, max) => {\n    return Math.min(max, Math.max(min, value));\n}\n\nexport const arrMean = (arr) => {\n    const sum = arr.reduce((a, b) => a + b, 0);\n    return (sum / arr.length) || 0;\n}\n\nexport const arrSum = (arr) => {\n    return arr.reduce((partialSum, a) => partialSum + a, 0);\n}\n\nexport const arrMax = (arr) => {\n    return Math.max(...arr);\n}\n\nexport const arrMin = (arr) => {\n    return Math.min(...arr);\n}\n\nexport const arrUnique = (arr) => {\n    return arr.filter((value, index, array) => array.indexOf(value) === index);\n}\n\nexport const sumProduct = (arr, weights) => {\n    return arr.reduce((s, v, i) => s + v * weights[i], 0);\n}\n\nexport const hexToRGB = (hex) => {\n    if (hex[\"levels\"]) {\n        return {\n            r: parseInt(hex[\"levels\"][0]),\n            g: parseInt(hex[\"levels\"][1]),\n            b: parseInt(hex[\"levels\"][2])\n        }\n    }\n\n    let result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16)\n    } : null;\n}\n\nexport const colorDistance = (a, b) => {\n    return Math.sqrt(Math.pow(a.r - b.r, 2) + Math.pow(a.g - b.g, 2) + Math.pow(a.b - b.b, 2));\n}","export const ALIGNMENT = {\n    \"A\": 10, // limit to the non-linear function\n    \"WEIGHTS\": [.8, .2] // alignment parts weights\n}\n\nexport const LEGIBILITY = {\n    \"MAX_CONSTRAINT\": 1,\n    \"WHITE_SPACE_FACTOR\": 3,\n    \"MODES\": [`OVERSET`, `JUSTIFY`,`ATTEMPT_JUSTIFY`],\n    \"DEFAULT_MAX_LIMIT_SCALE\": 1\n}\n\nexport const REGULARITY = {\n    \"A\": 10, // limit to the non-linear function\n}\n\nexport const SEMANTICS_EMPHASIS = {\n    \"MIN_RANGE\": 50,\n    \"THRESHOLD_VALID\": 0.2,\n    \"MODES\": [`DIF`, `MIN`]\n}\n\nexport const SEMANTICS_VISUALS = {\n    \"MAX_COLOR_DISTANCE\": 441.67\n}\n\nexport const SEMANTICS_LAYOUT = {\n    \"MODES\": [`RELATIVE`, `FIXED`]\n}\n\nexport const TYPEFACE_PARING = {\n    \"MODES\": [`BOTH`, `TYPE_FAMILY`, `CATEGORY`]\n}\n\nexport const VISUAL_BALANCE = {\n    \"VISUAL_CENTER_FT\": 20,\n}\n\nexport const WHITE_SPACE_FRACTION = {\n    \"OPTIMAL\": .5,\n    \"MIN_DISTANCE\": 10\n}\n\n\nexport default {\n    \"DEBUG\": false,\n}","/**\n * Legibility\n *\n * Measure the legibility of the text in the poster\n * it is related to the legibility of the sentence\n * and not the typeface shapes\n *\n * Expected return a value between 0 (good) and (1) bad\n *\n * Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * srebelo[at]dei.uc.pt\n *\n * v1.0.0 August 2018 (as part of evoPoster)\n * v2.0.0 November 2020 (as part of evoPoster)\n * v2.5.0 November 2021 (as part of evoPoster)\n * v3.0.0 November 2023\n */\n\nimport {arrMean, map} from \"../utils.js\";\nimport {LEGIBILITY} from \"../metrics.config.js\";\n\nconst MAX_CONSTRAINT = LEGIBILITY[\"MAX_CONSTRAINT\"];\nconst WHITE_SPACE_FACTOR = LEGIBILITY[\"WHITE_SPACE_FACTOR\"];\nconst DEFAULT_MAX_LIMIT_SCALE = LEGIBILITY[\"DEFAULT_MAX_LIMIT_SCALE\"];\nconst AVAILABLE_MODES = LEGIBILITY [\"MODES\"]\n\nexport const compute = (sentencesLength = [], minSize, mode= 'OVERSET', maxLimitScale= DEFAULT_MAX_LIMIT_SCALE) => {\n    if (!AVAILABLE_MODES.includes(mode)) {\n        mode = `OVERSET`;\n    }\n    let results = [];\n    let max = minSize * maxLimitScale;\n    for (let sentence of sentencesLength) {\n        let dif = minSize-sentence;\n        let value = MAX_CONSTRAINT;\n        switch (mode) {\n            case `JUSTIFY`:\n                value = justify(dif, max);\n                break;\n            case `ATTEMPT_JUSTIFY`:\n                value = attemptJustify(dif, max);\n                break;\n            default:\n                value = overset(dif, max);\n                break;\n        }\n        results.push(value);\n    }\n\n    // calculate mean\n    const mean = arrMean([...results]);\n\n    return mean;\n}\n\nconst overset = (value, max) => {\n    // only prejudice when text overfits the poster\n    // if dif bigger than 0\n    value = value >= 0 ? 0 : value;\n    // if dif lower than limit\n    value = value <= -max ? -max : value;\n    // transform in scale of 1 (bad) to 0 (good)\n    return map (value, -max, 0, MAX_CONSTRAINT, 0);\n}\n\nconst justify = (value, max) => {\n    // prejudice both overset and small lettering\n    value = Math.abs(value)\n    // if the dif is bigger than max\n    value = value > max ? max : value;\n    // transform in scale of 1 (bad) to 0 (good)\n    return map (value, max, 0, MAX_CONSTRAINT, 0);\n}\n\n// attempt to justify the text\n// prejudice more when the text overset box than when it is smaller\nconst attemptJustify = (value, max) => {\n    // if dif bigger than 0 (it is not overset), soften the value\n    value = value >= 0 ? value/WHITE_SPACE_FACTOR : value;\n    return justify(value, max);\n}\n\nexport { compute as default };","/**\n * Layout Semantics\n *\n * Measure the appropriate of the layout\n * based on the importance of the content\n * it considers that most important parts of content\n * are those have more emotions related\n *\n * return the mean of difference between all textboxes,\n * a value between 1 (good) and 0 (bad)\n *\n * two modes: RELATIVE and FIXED\n * RELATIVE mode is related to the composition height\n * FIXED height is related to the container's height\n *\n * Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * srebelo[at]dei.uc.pt\n *\n * v1.0.0 April 2020\n * v2.0.0 November 2023\n */\n\nimport {arrMean, arrSum} from \"../utils.js\";\nimport {SEMANTICS_LAYOUT} from \"../metrics.config.js\";\n\nconst AVAILABLE_MODES = SEMANTICS_LAYOUT[\"MODES\"];\n\nexport const compute = (textboxesHeights = [], dist = null, mode=`RELATIVE`, size = {height: 100, margin:[0,0,0,0]}) => {\n    // mode validation\n    if (!AVAILABLE_MODES.includes(mode)) mode = `RELATIVE`;\n\n    // define max height\n    let height = 0;\n    if (mode === `RELATIVE`) {\n        // using the textbox height\n        height = arrSum(textboxesHeights);\n    } else if (mode === `FIXED`) {\n        // using container height\n        height = size.height - ((size.height*size.margin[1]) + (size.height*size.margin[3]));\n    }\n    const percents = textboxesHeights.map((p) => p/height);\n\n    // calculate distances\n    let distances = [];\n    for (let i in dist) {\n        const dif = Math.abs(dist[i][3] - percents[i]);\n        distances.push(dif);\n    }\n\n    // return average\n    return (1-arrMean(distances));\n}\n\nexport { compute as default };","/**\n * Semantics Emphasis on Visuals\n *\n * Measure the appropriate of the visual features\n * based on the importance of the content\n * it considers that most important parts of content\n * are those have more emotions related\n *\n * return the mean of difference between all textboxes,\n * a value between 1 (good) and 0 (bad)\n *\n * two modes: MIN and DIF\n * MIN takes into account that the most important parts\n * are typeset in the min value possible in the container\n * DIF: take into account only the difference between the parts\n * selects a style and compare based on the distribution of emotions.\n *\n *\n *\n * Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * srebelo[at]dei.uc.pt\n *\n * v1.0.0 November 2023\n */\nimport {arrMax, arrMean, arrMin, arrSum, constraint, map} from \"../utils.js\";\nimport {SEMANTICS_EMPHASIS} from \"../metrics.config.js\";\n\nlet MIN_RANGE = SEMANTICS_EMPHASIS[\"MIN_RANGE\"];\nlet THRESHOLD_VALID = SEMANTICS_EMPHASIS[\"THRESHOLD_VALID\"];\nlet AVAILABLE_MODES = SEMANTICS_EMPHASIS[\"MODES\"];\n\n// by tradition, use more that a method to emphasize\n// the text is considered \"typecrime\".\n// this method enables turn on/off this feature\n// by using the param allowMultiple\nexport const compute = (textboxes, dist, noCurrentTypefaces = 1, allowMultiple = true, weights = [0.4, 0.3, 0.3]) => {\n    // if textboxes size is 1 ---> 1\n    const perDist = dist.map((e) => e[3]);\n\n    const fontWeight = checkDifferenceVariableFeature(textboxes.map((b) => b[\"weight\"]), perDist);\n    const fontStretch = checkDifferenceVariableFeature(textboxes.map((b) => b[\"font-stretch\"]), perDist);\n    let typefaceDesign = noCurrentTypefaces > 1 ? (checkDifferenceUniqueFeatures(textboxes.map((b) => b[\"font-stretch\"]), perDist)) : 0;\n\n    // way of combine and only checks one\n    let res = [fontWeight, fontStretch, typefaceDesign];\n    let weightedRes = res.map((x,i) => x*weights[i]);\n\n    let value;\n\n    if (!allowMultiple) {\n        // if not allowed multiple emphasis\n        // we check what fields are active\n        // and penalty when there is active fields\n        let active = res.map((r) => r > THRESHOLD_VALID);\n        let c = 0;\n        for (let a of active) {\n            if (a) {\n                c++;\n            }\n        }\n        value = arrMax(res)/c;\n    } else {\n        value = arrSum(weightedRes);\n    }\n\n    return value;\n}\n\n// check the levels\nconst checkDifferenceUniqueFeatures = (currentFeatures, dist) => {\n    // available semantic level\n    const uniqueValues = dist.filter((value, index, array) => array.indexOf(value) === index);\n    const target = [];\n\n    // define the target typeface for each semantic level\n    for (let uq of uniqueValues) {\n        for (let i=0; i<dist.length; i++) {\n            if (dist[i] === uq) {\n                target.push(currentFeatures[i]);\n                break;\n            }\n        }\n    }\n\n    // check if the target has duplicates\n    const duplicates = target.filter((item, index) => target.indexOf(item) !== index);\n\n    let value = 1;\n    // if there is duplicate in levels\n    // (if yes, difference is max)\n    if (!duplicates.length >= 1) {\n        // count the amount of tb not in the same typeface\n        let c = 0;\n        // for each typeface\n        for (let i in dist) {\n            let level = dist[i];\n            let currentValue = currentFeatures[i];\n            // get unique index of current semantic level\n            let index = uniqueValues.indexOf(level);\n            // get target value\n            let targetValue = target[index];\n            if (currentValue !== targetValue) {\n                // if not the same as target\n                c++;\n            }\n        }\n        // map value to a value between 0 (no difference) and 1 (max difference)\n        value = map(c, 0, currentFeatures.length, 0, 1);\n    }\n\n    return value;\n}\n\nconst checkDifferenceVariableFeature = (currentFeatures, dist, mode = `DIF`) => {\n    if (!AVAILABLE_MODES.includes(mode)) {\n        mode = `DIF`;\n    }\n    // max feature range\n    const maxFeature = arrMax(currentFeatures);\n    const minFeature = arrMin(currentFeatures);\n    let range = Math.abs(maxFeature - minFeature);\n    if (range < MIN_RANGE) {\n        return 1;\n    }\n\n    // semantic data range\n    const maxSemantic = arrMax(dist);\n    const minSemantic = arrMin(dist);\n\n    // consider the current variable minimum\n    let def = minFeature;\n    if (mode === `DIF`) {\n        // selects a style used in the first min semantic textbox\n        for (let i in dist) {\n            if (dist[i] === minSemantic) {\n                // consider the difference\n                def = currentFeatures[i];\n                break;\n            }\n        }\n    }\n\n    // create target feature values\n    const target = dist.map((e) => {\n        // The most neutral sentence are the most regular\n        let v = map(e, minSemantic, maxSemantic, 0, range);\n        v = constraint(v, 0, range);\n        return v;\n    });\n\n    // distance to target\n    const current = [];\n    for (let i in currentFeatures) {\n        let w = currentFeatures[i];\n        let currentDistance = Math.abs(w - def);\n        let dif = Math.abs(currentDistance - target[i]);\n        current.push(dif);\n    }\n\n    let mean = map(arrMean(current), 0, range, 1, 0);\n    return constraint(mean, 0, 1);\n}\n\n\n\n\nexport { compute as default };","export default {\n    anger : {\n        color: {\n            typography: [`#ff0000`, `#00ff00`],\n            background: [`#ff0000`]\n        },\n        typefaces: [`sans-serif`, `neo-grotesque`]\n    },\n    joy: {\n        color: {\n            typography: [],\n            background: [`#ffff00`, `#00ff00`]\n        },\n        typefaces: [`sans-serif`, `serif`]\n    },\n    trust: {\n        color: {\n            typography: [],\n            background: [`#0000ff`, `#00ff00`]\n        },\n        typefaces: [`neo-grotesque`]\n    },\n    sadness: {\n        color: {\n            typography: [],\n            background: [`#0071b6`]\n        },\n        typefaces: []\n    },\n    disgust: {\n        color: {\n            typography: [`#800080`],\n            background: []\n        },\n        typefaces: []\n    }\n}","/**\n * Semantic Visuals Measure\n *\n * This function assesses the appropriateness of visual features (type design and colour)\n * based on the emotions collected. It takes into account the configuration file \"visual-semantics.config.js\".\n *\n * The function returns the mean difference between all textboxes,\n * yielding a value between 1 (good) and 0 (bad).\n * If there is no information pertaining to a particular emotion, the value defaults to 1.\n *\n * As of now, the function exclusively considers the predominant emotions from ML analysis.\n *\n * Author: Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * Contact: srebelo[at]dei.uc.pt\n *\n * Version: 1.0.0 (November 2023)\n */\n\nimport {SEMANTICS_VISUALS} from \"../metrics.config.js\";\n\nconst MAX_COLOR_DISTANCE = SEMANTICS_VISUALS[\"MAX_COLOR_DISTANCE\"];\n\nimport * as configurationFile from \"../../semantics-visual.config.js\";\nimport {arrMean, colorDistance, hexToRGB, constraint} from \"../utils.js\";\n\n\nexport const compute = async (data, textboxes, background, typefaceData, config = configurationFile) => {\n\n    let emotion = data.predominant.emotion;\n\n    if (config[\"default\"][emotion] === undefined) return 1;\n\n    const targetTypefaceColors = config[\"default\"][emotion][\"color\"][\"typography\"];\n    const targetBackgroundColors = config[\"default\"][emotion][\"color\"][\"background\"];\n    const targetTypographyFeatures = config[\"default\"][emotion][\"typefaces\"];\n\n    // typography colour\n    let meanTypefaceColorDistance = 1;\n    if (targetTypefaceColors !== undefined && targetTypefaceColors.length > 0) {\n        let typefaceColorsDistances = [];\n        for (let t of textboxes) {\n            let c = hexToRGB(t.color);\n            let typefaceColorsDist = Number.MAX_VALUE;\n            for (let targetColor of targetTypefaceColors) {\n                targetColor = hexToRGB(targetColor);\n                let distance = colorDistance(c, targetColor)\n                if (distance < typefaceColorsDist) {\n                    typefaceColorsDist = distance;\n                }\n            }\n            typefaceColorsDistances.push(typefaceColorsDist);\n        }\n\n        meanTypefaceColorDistance = typefaceColorsDistances.length < 1 ? 1 : arrMean(typefaceColorsDistances);\n        meanTypefaceColorDistance /= MAX_COLOR_DISTANCE;\n        meanTypefaceColorDistance = constraint(1-meanTypefaceColorDistance, 0, 1);\n    }\n\n    // background colour\n    let meanTypefaceBackgroundDistance = 1;\n    if (targetBackgroundColors !== undefined && targetBackgroundColors.length !== 0) {\n        let backgroundColorsDistances = [];\n        meanTypefaceBackgroundDistance = 0;\n        for (let c of background) {\n            c = hexToRGB(c);\n            let backgroundColorsDist = Number.MAX_VALUE;\n            for (let targetColor of targetBackgroundColors) {\n                targetColor = hexToRGB(targetColor);\n                let distance = colorDistance(c, targetColor);\n                if (distance < backgroundColorsDist) {\n                    backgroundColorsDist = distance;\n                }\n            }\n            backgroundColorsDistances.push(backgroundColorsDist);\n        }\n\n        meanTypefaceBackgroundDistance = meanTypefaceBackgroundDistance.length < 1 ? 1 : arrMean(backgroundColorsDistances);\n        meanTypefaceBackgroundDistance /= MAX_COLOR_DISTANCE;\n        meanTypefaceBackgroundDistance = constraint(1-meanTypefaceBackgroundDistance, 0, 1);\n    }\n\n    // typeface\n    let meanTypefaceError = 1;\n    if (targetTypographyFeatures !== undefined && targetTypographyFeatures.length > 0) {\n        let fontsTags = [];\n        for (let t of textboxes) {\n            let tbTagsValue = 0;\n            const typefaceIndex = typefaceData.map(t => t.family).indexOf(t[\"typeface\"]);\n            const tags = typefaceData[typefaceIndex][\"tags\"];\n            for (let t of targetTypographyFeatures) {\n                if (tags.includes(t)) {\n                    tbTagsValue += (1/targetTypographyFeatures.length)\n                }\n            }\n            fontsTags.push(tbTagsValue);\n        }\n\n        meanTypefaceError = fontsTags.length < 1 ? 1 : arrMean(fontsTags);\n        meanTypefaceError = constraint(meanTypefaceError, 0, 1);\n    }\n\n    return (meanTypefaceColorDistance + meanTypefaceBackgroundDistance + meanTypefaceError)/3;\n\n\n}\n\n\nexport {compute as default};","/**\n * Alignment metric\n *\n * Estimate if the horizontal alignment of text boxes follows a regular pattern\n * Based on Harrington et al. (2004).\n *\n * Include the check if the text Alignment is the same (part B).\n * User can modify the value of WEIGHTS when necessary.\n *\n * return a value between 1 (good) and 0 (bad)\n *\n * Author: Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * Contact: srebelo[at]dei.uc.pt\n *\n * Version 1.0.0 (March 2020)\n * Version: 1.5.0 (November 2023)\n */\n\nimport {arrMean, arrUnique, sumProduct} from \"../utils.js\";\nimport {ALIGNMENT} from \"../metrics.config.js\";\n\nconst A = ALIGNMENT[\"A\"]\nconst WEIGHTS = ALIGNMENT[\"WEIGHTS\"];\n\nexport const compute = (sentenceWidth, textAlignment, weights = WEIGHTS) => {\n    if (sentenceWidth.length < 2) {\n        return 1;\n    }\n\n    let histogram = sentenceWidth;\n    let results = [];\n\n    for (let i = 0; i<histogram.length-1; i++) {\n        let z = Math.abs(histogram[i] - histogram [i+1]);\n        let v = A / (A + z);\n        results.push(v);\n    }\n\n    let resHistogramDif = arrMean(results);\n    let availableTextAligns = arrUnique(textAlignment).length;\n    let resTextAlign = 1/availableTextAligns;\n\n    let res = sumProduct([resHistogramDif, resTextAlign], weights);\n    return res;\n}\n\nexport {compute as default};","import {colorDistance, hexToRGB} from \"../utils.js\";\nimport {WHITE_SPACE_FRACTION} from \"../metrics.config.js\";\n\n/**\n * White Space Fraction metric\n *\n * Assess the white space factor, i.e. the amount of the result that is background.\n * Based on Harrington et al. (2004).\n *\n * Traditionally, white space (including margins) should total about half of the total page area.\n *\n * We decided made this in other way, using the pixels of image that are equals to background color\n *\n * return a value between 1 (good) and 0 (bad)\n * in first version, we used a no-linear method and onlyy works with solid backgrounds\n *\n * Author: Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * Contact: srebelo[at]dei.uc.pt\n *\n * Version 1.0.0 (March 2020)\n * Version: 1.5.0 (November 2023)\n */\n\nconst OPTIMAL = WHITE_SPACE_FRACTION[\"OPTIMAL\"];\nconst MIN_DISTANCE = WHITE_SPACE_FRACTION[\"MIN_DISTANCE\"];\n\nexport const compute = (img, color, amount = null, optimal = OPTIMAL) => {\n    if (amount === null) {\n        color = hexToRGB(color);\n        amount = percentTypographyColor(img, color, img.pixelDensity());\n    }\n\n    const res = 1-4*Math.pow((amount - optimal), 2);\n\n    return res;\n}\n\nconst percentTypographyColor = (img, c, d=1) => {\n    let amount = 0;\n    let distances = [];\n    let size = img.width * d * img.height * d ;\n    img.loadPixels();\n    for (let i = 0; i < 4 * size; i += 4) {\n        let current = {\n            r: img.pixels[i],\n            g: img.pixels[i+1],\n            b: img.pixels[i+2]\n        }\n        const distance = colorDistance(current, c);\n        distances.push(distance);\n        if (distance < MIN_DISTANCE) {\n            amount++;\n        }\n    }\n    return amount/size;\n}\n\nexport {compute as default};","import {arrUnique} from \"../utils.js\";\nimport {TYPEFACE_PARING} from \"../metrics.config.js\";\n\n/**\n * Typeface Pairing Metric\n *\n * Checks if the employed typefaces pair well together.\n * Since each typeface is related to a line of text,\n * this metric considers the typeface name and the classification.\n * Typefaces should be included in the configuration file with corresponding classification values.\n *\n * It had three modes:\n * TYPEFACE: values the use of the same typeface\n * CATEGORY: values the use of typefaces in the same category\n * BOTH: values both\n *\n *\n * Returns a value between 1 (good) and 0 (bad) to indicate compatibility.\n *\n * Author: Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * Contact: srebelo[at]dei.uc.pt\n *\n * Version 1.0.0 (March 2020)\n * Updated Version: 1.5.0 (November 2023)\n */\n\nconst AVAILABLE_MODES = TYPEFACE_PARING[\"MODES\"]\n\nexport const compute = (typefaces, availableTypefaces, mode = `BOTH`) => {\n    if (!AVAILABLE_MODES.includes(mode))  {\n        mode = `BOTH`;\n    }\n\n    let weights = [.5, .5]; // heights to BOTH mode\n    if (mode === `TYPE_FAMILY`) {\n        weights = [1, 0];\n    } else if (mode === `CATEGORY`) {\n        weights = [0, 1];\n    }\n\n    let categories = [];\n    let usedTypefaces = arrUnique(typefaces);\n    let categoriesFactor = 0, typefaceFactor = 0;\n\n    if (mode !== `TYPE_FAMILY`) {\n        const typefacesNames = availableTypefaces.map(a => a[\"family\"]);\n        const typefacesClassification = availableTypefaces.map(a => a[\"category\"]);\n\n        for (let typeface of usedTypefaces) {\n            const index = typefacesNames.indexOf(typeface);\n            if (index === -1) {\n                categories.push(`undefined`);\n            } else {\n                categories.push(typefacesClassification[index]);\n            }\n        }\n\n        categories = arrUnique(categories);\n        categoriesFactor = 1/categories.length;\n    }\n\n    if (mode !== `CATEGORY`) {\n        typefaceFactor = 1 / usedTypefaces.length;\n    }\n\n    const res = [typefaceFactor, categoriesFactor].reduce((s, v, i) => s + v * weights[i], 0);\n\n    return res;\n}\n\nexport {compute as default};","/**\n * Visual Balance metric\n *\n * Estimate the visual balance (centred) of the composition.\n * Based on Harrington et al. (2004)\n *\n *\n * Author: Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * Contact: srebelo[at]dei.uc.pt\n *\n * Version 1.0.0 (March 2020)\n * Version: 1.5.0 (November 2023)\n */\n\nimport {arrSum} from \"../utils.js\";\nimport {VISUAL_BALANCE} from \"../metrics.config.js\";\n\n// visual center factor\n// By default, the visual center is taken to be offset a twentieth of the page height towards the top\nconst VISUAL_CENTER_FT = VISUAL_BALANCE[\"VISUAL_CENTER_FT\"];\n\nexport const compute = async (img = null, size, rows, widths, heights, visualWeights = null) => {\n    const dx = size[\"width\"];\n    const dy = size[\"height\"];\n\n    const vw = visualWeights === null ? await visualWeight(img, rows, widths, heights) : visualWeights;\n    const bo = balanceCenter(vw, widths, heights);\n    const vo = visualCenter(dx, dy);\n\n    // calculate central Balance\n    let cb = Math.pow(((bo.x-vo.x)/dx), 2) + Math.pow(((bo.y-vo.y)/dy), 2);\n    cb = 1-Math.pow(Math.abs(cb/2), 1/2);\n\n    return cb;\n}\n\n\nconst balanceCenter = (vws, widths, heights) => {\n    // get text box center\n    const vc = [];\n    for (let i in heights) {\n        vc.push(visualCenter(widths[i], heights[i]));\n    }\n\n    // get page balance center\n    let posX = 0, posY = 0;\n    const m = arrSum(vws);\n\n    for (let i in vws) {\n        posX += vc[i].x*vws[i];\n        posY += vc[i].y*vws[i];\n    }\n\n    posX /= m;\n    posY /= m;\n\n    return {\n        x: posX,\n        y: posY\n    }\n}\n\n\n/**\n* Calculate the visual centre of a element\n* The visual center lies halfway between the left and right edges\n* the visual center is taken to be offset a twentieth of the page height towards the top\n*/\nconst visualCenter = (width, height) => {\n    return {\n        x: width/2,\n        y: height/2 - (height/VISUAL_CENTER_FT)\n    }\n}\n\n/**\n * calculate the visual weight of a object\n * visual weight = area x optical density\n */\nconst visualWeight = async (img, rows, widths, heights) => {\n    let areas = [];\n    let opticalDensity = [];\n\n    for (let i in widths) {\n\n        // compute areas\n        areas.push(widths[i] * heights[i]);\n\n        // compute visual weight\n        const rendering = await img.get(\n            0,\n            img.height/2 + rows[\"center\"][i],\n            img.width,\n            rows[\"l\"][i]\n        );\n\n        await rendering.loadPixels();\n\n        let r = 0, g = 0, b = 0;\n        const realPixelsSize = rendering.pixels.length/4;\n\n        for (let i=0; i < rendering.pixels.length; i+=4) {\n            r += rendering.pixels[i];\n            g += rendering.pixels[i+1];\n            b += rendering.pixels[i+2];\n        }\n\n        r = Math.round(r/realPixelsSize);\n        g = Math.round(g/realPixelsSize);\n        b = Math.round(b/realPixelsSize);\n\n        const avgLuma = (0.2126*r + 0.7152*g + 0.0722*b);\n        const t = avgLuma / 255;\n        opticalDensity.push(-Math.log10(t));\n    }\n\n    return areas.map((a, i) => a * opticalDensity[i]);\n}\n\n\nexport {compute as default};\n","/**\n * Evaluation metrics for evo-poster\n * Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * srebelo[at]dei.uc.pt\n *\n * v0.0.1 July 2023\n */\n\nimport * as Legibility from \"./metrics/Legibility.mjs\";\nimport * as GridAppropriateSize from \"./metrics/GridAppropriateSize.mjs\";\nimport * as SemanticsLayout from \"./metrics/SemanticsLayout.mjs\";\nimport * as SemanticsEmphasis from \"./metrics/SemanticsEmphasis.mjs\";\nimport * as SemanticsVisuals from \"./metrics/SemanticVisuals.mjs\";\nimport * as Alignment from \"./metrics/Alignment.mjs\";\nimport * as Regularity from \"./metrics/Regularity.mjs\";\nimport * as WhiteSpaceFraction from \"./metrics/WhiteSpaceFraction.mjs\";\nimport * as TypefaceParing from \"./metrics/TypefaceParing.mjs\";\nimport * as VisualBalance from \"./metrics/VisualBalance.mjs\";\n\n\nexport const legibility = Legibility.compute;\nexport const gridAppropriateSize = GridAppropriateSize.compute;\nexport const semanticsLayout = SemanticsLayout.compute;\nexport const semanticsEmphasis = SemanticsEmphasis.compute;\nexport const semanticsVisuals = SemanticsVisuals.compute;\nexport const alignment = Alignment.compute;\nexport const regularity = Regularity.compute;\nexport const whiteSpaceFraction = WhiteSpaceFraction.compute;\nexport const typefaceParing = TypefaceParing.compute;\nexport const visualBalance = VisualBalance.compute;\n\nexport default () => {\n    console.log (`@evo-poster · evaluator v2.00`)\n}\n","/**\n * Grid Size Appropriateness\n *\n * Measure the appropriate of the used grid to the size of container\n * it is related to if the width and height of the grid is\n * in accordance with poster size\n *\n * Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * srebelo[at]dei.uc.pt\n *\n * v1.0.0 November 2023\n */\n\nimport * as CONFIG from \"../metrics.config.js\";\n\nconst DEBUG = CONFIG[\"default\"][\"DEBUG\"];\n\nexport const compute = (containerWidth, containerHeight, rows = [], columns = [], margins = {left:0, top:0, right:0, bottom:0}) => {\n    let invalid = false;\n    // debug\n    let msg = \"\";\n\n    // height calculation\n    let height = Math.abs(margins.top)+Math.abs(margins.bottom);\n    for (let r of rows) {\n        height = height + parseFloat(r);\n    }\n    // width calculation\n    let width = Math.abs(margins.left)+Math.abs(margins.right);\n    for (let r of columns) {\n        width = width + parseFloat(r);\n    }\n\n    width = Math.round(width);\n    height = Math.round(height);\n\n    if (height > containerHeight) {\n        invalid = true;\n        msg += `Grid height is bigger than container (grid:${height}, container:${containerHeight}). `;\n    } else if (height < containerHeight) {\n        msg += `Grid and container height are not the same (grid:${height}, container:${containerHeight}). `;\n    }\n\n    if (width > containerWidth) {\n        invalid = true;\n        msg += `Grid width is bigger than container (grid:${width}, container:${containerWidth}). `;\n    } else if (width < containerWidth) {\n        msg += `Grid and container width are not the same (grid:${width}, container:${containerWidth}). `;\n    }\n\n    if (msg !== \"\" && DEBUG) {\n        console.warn(msg);\n    }\n\n    return invalid ? 1 : 0;\n}\n\nexport { compute as default };","/**\n * Alignment metric\n *\n * Estimate if the text boxes follows a regular vertical pattern\n * Based on Harrington et al. (2004).\n *\n *\n * return a value between 1 (good) and 0 (bad)\n *\n * Author: Sérgio M. Rebelo\n * CDV lab. (CMS, CISUC, Portugal)\n * Contact: srebelo[at]dei.uc.pt\n *\n * Version 1.0.0 (March 2020)\n * Version: 1.5.0 (November 2023)\n */\n\nimport {arrMean} from \"../utils.js\";\nimport {REGULARITY} from \"../metrics.config.js\";\n\nconst A = REGULARITY[\"A\"];\n\nexport const compute = (heights) => {\n    if (heights.length < 2) {\n        return 1;\n    }\n\n    const histogram = heights;\n\n    let results = [];\n\n    for (let i = 0; i<histogram.length-1; i++) {\n        let z = Math.abs(histogram[i] - histogram [i+1]);\n        let v = A / (A + z);\n        results.push(v);\n    }\n\n    const res = arrMean(results);\n\n    return res;\n}\n\nexport {compute as default};"],"names":["map","value","minA","maxA","minB","maxB","constraint","min","max","Math","arrMean","arr","reduce","a","b","length","arrSum","partialSum","arrMax","arrMin","arrUnique","filter","index","array","indexOf","hexToRGB","hex","r","parseInt","g","result","exec","colorDistance","sqrt","pow","ALIGNMENT","LEGIBILITY","MAX_CONSTRAINT","WHITE_SPACE_FACTOR","MODES","DEFAULT_MAX_LIMIT_SCALE","SEMANTICS_EMPHASIS","MIN_RANGE","THRESHOLD_VALID","TYPEFACE_PARING","WHITE_SPACE_FRACTION","AVAILABLE_MODES","overset","justify","abs","attemptJustify","checkDifferenceUniqueFeatures","currentFeatures","dist","uniqueValues","target","uq","i","push","duplicates","item","c","level","currentValue","checkDifferenceVariableFeature","mode","includes","maxFeature","minFeature","range","maxSemantic","minSemantic","def","e","v","current","w","currentDistance","dif","mean","semanticsVisual_config","anger","color","typography","background","typefaces","joy","trust","sadness","disgust","MAX_COLOR_DISTANCE","A","WEIGHTS","OPTIMAL","MIN_DISTANCE","percentTypographyColor","img","d","amount","size","width","height","loadPixels","pixels","balanceCenter","vws","widths","heights","vc","visualCenter","posX","posY","m","x","y","visualWeight","async","rows","areas","opticalDensity","rendering","get","realPixelsSize","round","t","log10","legibility","sentencesLength","minSize","maxLimitScale","results","sentence","gridAppropriateSize","containerWidth","containerHeight","columns","margins","left","top","right","bottom","invalid","msg","parseFloat","semanticsLayout","textboxesHeights","margin","percents","p","distances","semanticsEmphasis","textboxes","noCurrentTypefaces","allowMultiple","weights","perDist","res","weightedRes","active","semanticsVisuals","data","typefaceData","config","configurationFile","emotion","predominant","undefined","targetTypefaceColors","targetBackgroundColors","targetTypographyFeatures","meanTypefaceColorDistance","typefaceColorsDistances","typefaceColorsDist","Number","MAX_VALUE","targetColor","distance","meanTypefaceBackgroundDistance","backgroundColorsDistances","backgroundColorsDist","meanTypefaceError","fontsTags","tbTagsValue","typefaceIndex","family","tags","alignment","sentenceWidth","textAlignment","histogram","z","s","sumProduct","regularity","whiteSpaceFraction","optimal","pixelDensity","typefaceParing","availableTypefaces","categories","usedTypefaces","categoriesFactor","typefaceFactor","typefacesNames","typefacesClassification","typeface","visualBalance","visualWeights","dx","dy","vw","bo","vo","cb","console","log"],"mappings":"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"}